<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Konnect Setup :: API Management with Kong Konnect</title>
    <link>http://localhost:1313/11-konnect-setup/index.html</link>
    <description>This chapter will walk you through&#xA;Konnect Control Plane and Data Plane creation using Kong Gateway Operator (KGO). Scale Kong data plane nodes on Kubernetes using HPA - Horizontal Pod Autoscaler. Access Kong data plane through Minikube tunnel Here’s a Reference Architecture that will be implemented in this workshop:&#xA;Kong Konnect Control Plane: responsible for managing your APIs Kong Konnect Data Plane: connected to the Control Plane, it is responsible for processing all the incoming requests sent by the consumers. Kong provides a plugin framework, where each one of them is responsible for a specific functionality. As a can see, there are two main collections of plugins: On the left, the historic and regular API Gateway plugins, implementing all sort of policies including, for example, OIDC based Authentication processes with Keycloak, Amazon Cognito and Okta or Observability with Prometheus/Grafana and Dynatrace. On the right, another plugin collection for AI-based use cases. For example, the AI Rate Limiting plugin implements policies like this based on the number of tokens consumed be the requests. Or, as another example is the AI Semantic Cache plugin, which caches data based on the semantics related to the responses coming from the LLM models. Kong AI Gateway supports, out of the box, a variety of infrastructures, including not just OpenAI, but also Amazon Bedrock, Google Gemini, Mistral, Anthropic, etc. In order to deal with embeddings, the Gateway also supports also vector databases. Kong Gateway protects not just the LLM Models but also the upstream services, including your application micros surfaces or services. Konnect Control Plane After Konnect registration, you need to create your first Control Plane. There are multiple ways to do it:</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/11-konnect-setup/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Minikube</title>
      <link>http://localhost:1313/11-konnect-setup/110-minikube/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/11-konnect-setup/110-minikube/index.html</guid>
      <description>We are going to deploy our Data Plane in a Minikube Cluster over Podman. You can start Podman with:&#xA;podman machine set --memory 8196 podman machine start If you want to stop it run: podman machine stop Then you can install Minikube with: minikube start --driver=podman --memory=&#39;no-limit&#39; Use should see your cluster running with: kubectl get all --all-namespaces Typical output is:&#xA;NAMESPACE NAME READY STATUS RESTARTS AGE kube-system pod/coredns-674b8bbfcf-xrllp 0/1 Running 0 12s kube-system pod/etcd-minikube 1/1 Running 0 18s kube-system pod/kube-apiserver-minikube 1/1 Running 0 18s kube-system pod/kube-controller-manager-minikube 1/1 Running 0 18s kube-system pod/kube-proxy-xkfn9 1/1 Running 0 13s kube-system pod/kube-scheduler-minikube 1/1 Running 0 18s kube-system pod/storage-provisioner 1/1 Running 0 17s NAMESPACE NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE default service/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 19s kube-system service/kube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP,9153/TCP 18s NAMESPACE NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE kube-system daemonset.apps/kube-proxy 1 1 1 1 1 kubernetes.io/os=linux 18s NAMESPACE NAME READY UP-TO-DATE AVAILABLE AGE kube-system deployment.apps/coredns 0/1 1 0 18s NAMESPACE NAME DESIRED CURRENT READY AGE kube-system replicaset.apps/coredns-674b8bbfcf 1 1 0 12s To be able to consume the Kubernetes Load Balancer Services, in another terminal run: minikube tunnel</description>
    </item>
    <item>
      <title>PAT - Personal Access Token</title>
      <link>http://localhost:1313/11-konnect-setup/111-personal-access-token/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/11-konnect-setup/111-personal-access-token/index.html</guid>
      <description>KGO requires a Konnect Personal Access Token (PAT) for creating the Control Plane. To generate your PAT, click on your initials in the upper right corner of the Konnect home page, then select Personal Access Tokens. Click on + Generate Token, name your PAT, set its expiration time, and be sure to copy and save it, as Konnect won’t display it again.</description>
    </item>
    <item>
      <title>Kong Gateway Operator</title>
      <link>http://localhost:1313/11-konnect-setup/112-kgo-installation/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/11-konnect-setup/112-kgo-installation/index.html</guid>
      <description>Install the Operator To get started let’s install the Operator:&#xA;helm repo add kong https://charts.konghq.com helm repo update kong helm upgrade --install kgo kong/gateway-operator \ -n kong-system \ --create-namespace \ --set image.tag=1.6.2 \ --set kubernetes-configuration-crds.enabled=true \ --set env.ENABLE_CONTROLLER_KONNECT=true You can check the Operator’s log with: kubectl logs $(kubectl get pod -n kong-system -o json | jq -r &#39;.items[].metadata | select(.name | startswith(&#34;kgo-gateway-operator&#34;))&#39; | jq -r &#39;.name&#39;) -n kong-system Kong-gratulations! have now reached the end of this module by creating a Kong Operator. You can now click Next to proceed with the next module.</description>
    </item>
    <item>
      <title>Control Plane and Data Plane</title>
      <link>http://localhost:1313/11-konnect-setup/113-cp-dp/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/11-konnect-setup/113-cp-dp/index.html</guid>
      <description>Control Plane Deployment The following declaration defines an Authentication Configuration, based on the Kubernetes Secret and referring to a Konnect API URL, and the actual Konnect Control Plane.&#xA;cat &lt;&lt;EOF | kubectl apply -f - kind: KonnectAPIAuthConfiguration apiVersion: konnect.konghq.com/v1alpha1 metadata: name: konnect-api-auth-conf namespace: kong spec: type: secretRef secretRef: name: konnect-pat namespace: kong serverURL: us.api.konghq.com --- kind: KonnectGatewayControlPlane apiVersion: konnect.konghq.com/v1alpha1 metadata: name: kong-workshop namespace: kong spec: name: kong-workshop konnect: authRef: name: konnect-api-auth-conf EOF Expected Sample Output</description>
    </item>
    <item>
      <title>Data Plane Elasticity</title>
      <link>http://localhost:1313/11-konnect-setup/114-elasticity/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/11-konnect-setup/114-elasticity/index.html</guid>
      <description>One of the most important capabilities provided by Kubernetes is to easily scale out a Deployment. With a single command we can create or terminate pod replicas in order to optimally support a given throughput.&#xA;This capability is especially interesting for Kubernetes applications like Kong for Kubernetes Ingress Controller.&#xA;Here’s our deployment before scaling it out:&#xA;kubectl get service -n kong Sample Output&#xA;NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE dataplane-admin-dataplane1-x9n6r ClusterIP None &lt;none&gt; 8444/TCP 20h proxy1 LoadBalancer 10.100.234.223 k8s-kong-proxy1-518c8abdcc-a10b0ef08ae8ba02.elb.us-east-2.amazonaws.com 80:32290/TCP,443:31084/TCP 20h Notice, at this point in the workshop, there is only one pod taking data plane traffic.</description>
    </item>
  </channel>
</rss>